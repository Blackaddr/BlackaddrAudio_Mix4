/*
 * Company: Blackaddr Audio
 * Effect Name: Mix4
 * Description:
 *
 * This file was auto-generated by Aviate Audio Effect Creator for the Multiverse.
 */
#include <cmath>
#include "Aviate/EfxPrint.h"
#include "Mix4.h"

using namespace Aviate;

namespace BlackaddrAudio_Mix4 {

constexpr float PI_F = static_cast<float>(M_PI);

constexpr float LEVEL_MIN_DB = -60.0f;
constexpr float LEVEL_MAX_DB = 12.0f;
constexpr float MASTER_MIN_DB = -60.0f;
constexpr float MASTER_MAX_DB = 20.0f;

static float levelDb(float volDb)
{
    float levelOut;
    if (volDb <= -80.0f) { levelOut = 0.0f; }
    else {
        if (volDb >= 12.0f) { volDb = 12.0f; }
        levelOut = powf(10.0f, volDb/20.0f);
    }
    return levelOut;
}

Mix4::Mix4()
: AudioStream(NUM_INPUTS, m_inputQueueArray)
{
    // perform any necessary class initialization here
}

Mix4::~Mix4()
{
    // perform any necessary clean up here, though destructors are not
    // called on the hardware, only in the simulator.
}

void Mix4::update(void)
{
    if (!m_enable) { return; }  // check if disabled

    audio_block_t* inputBlock[NUM_INPUTS];
    bool processIn[NUM_INPUTS];
    bool inputFound = false;

    for (unsigned input = 0; input < NUM_INPUTS; input++) {
        inputBlock[input] = receiveReadOnly(input);
        processIn[input] = static_cast<bool>(inputBlock[input]);
        inputFound |= processIn[input];
    }

	if ( (!inputFound) || m_bypass) { // no inputs found, or in bypass mode
        for (unsigned input = 0; input < NUM_INPUTS; input++) {
            // attempt bypass
            if (input < NUM_OUTPUTS) { // only transmit bypass from corresponding input to output channel
                if (processIn[input]) {
                    transmit(inputBlock[input], input);
                }
            }
            if (inputBlock[input]) { release(inputBlock[input]); }  // release any acquired input blocks
        }
		return;
	}

    // check to make sure we can allocate the output blocks
    audio_block_t* outputBlock[NUM_OUTPUTS];
    bool allocateFailed = false;
    for (unsigned output = 0; output < NUM_OUTPUTS; output++) {
        outputBlock[output] = allocate();
        allocateFailed |= (!outputBlock[output]);
    }
    if (allocateFailed) {  // cleanup and return
        EFX_PRINT(Serial.printf("Mix4::update(): allocate failed\n\r"));
        for (unsigned output = 0; output < NUM_OUTPUTS; output++) {
            if (outputBlock[output]) { release(outputBlock[output]); }
        }
        for (unsigned input = 0; input < NUM_INPUTS; input++) {
            if (inputBlock[input]) { release(inputBlock[input]); }
        }
        return;
    }
    // at this point we are guarenteed to have valid output blocks and at least one input block

    // Use the first valid input fo the input peak
    for (unsigned input = 0; input < NUM_INPUTS; input++) {
        if (processIn[input]) { m_updateInputPeak(inputBlock[input]); break;}
    }

	const size_t AUDIO_BLOCK_SIZE = AUDIO_SAMPLES_PER_BLOCK;
	float float_input_buffer[AUDIO_BLOCK_SIZE];
    float float_output_buffer[AUDIO_BLOCK_SIZE];

    float inputLevel[NUM_INPUTS] = {m_channel1level, m_channel2level, m_channel3level, m_channel4level};
    float inputPan[NUM_INPUTS]   = {m_channel1pan,   m_channel2pan,   m_channel3pan,   m_channel4pan};
    float masterLevel[NUM_OUTPUTS] = { m_master1, m_master2};

    for (unsigned output = 0; output < NUM_OUTPUTS; output++) {
        memset((void*)float_output_buffer, 0, AUDIO_SAMPLES_PER_BLOCK * sizeof(float));  // clear the output buffer

        for (unsigned input = 0; input < NUM_INPUTS; input++) {
            if (!processIn[input]) { continue; } // skip unconnected inputs

            arm_q15_to_float(inputBlock[input]->data, float_input_buffer, AUDIO_SAMPLES_PER_BLOCK);   // convert input to float

            // perform leveling and panning
            float panFactor;
            if (output == 0) {  // output bus 0
                panFactor = 0.5f * (1.0f - inputPan[input]);
            } else {  // output bus 1
                panFactor = 0.5f * (1.0f + inputPan[input]);
            }

            arm_scale_f32(float_input_buffer, inputLevel[input] * panFactor * m_volume * masterLevel[output], float_input_buffer, AUDIO_SAMPLES_PER_BLOCK);
            arm_add_f32(float_input_buffer, float_output_buffer, float_output_buffer, AUDIO_SAMPLES_PER_BLOCK);  // add to the output bbus
        }
        arm_float_to_q15(float_output_buffer, outputBlock[output]->data, AUDIO_SAMPLES_PER_BLOCK);  // convert back to 16-bit

        if (output == 0) { m_updateOutputPeak(outputBlock[0]); }  // use the first output channel for output peaking
        transmit(outputBlock[output], output);
        release(outputBlock[output]);
    }

    // release inputs
    for (unsigned input = 0; input < NUM_INPUTS; input++) {
        if (processIn[input]) { release(inputBlock[input]); }
    }

}

void Mix4::volume(float value)
{
    float volDbValue = -40.0f + (value * 50.0f);  // remap the normalized value to represent -40dB to +10dB
    volumeDb(volDbValue);  // AudioEffectWrapper has built-in volume function in dB
}

void Mix4::channel1level(float value)
{
    // perform any necessary conversion to user variables, validation, etc.
    m_channel1level = levelDb(getUserParamValue(Channel1Level_e,value));
}

void Mix4::channel2level(float value)
{
    // perform any necessary conversion to user variables, validation, etc.
    m_channel2level = levelDb(getUserParamValue(Channel2Level_e,value));
}

void Mix4::channel3level(float value)
{
    // perform any necessary conversion to user variables, validation, etc.
    m_channel3level = levelDb(getUserParamValue(Channel3Level_e,value));
}

void Mix4::channel4level(float value)
{
    // perform any necessary conversion to user variables, validation, etc.
    m_channel4level = levelDb(getUserParamValue(Channel4Level_e,value));
}

void Mix4::channel1pan(float value)
{
    // perform any necessary conversion to user variables, validation, etc.
    m_channel1pan = std::sin(0.5f * PI_F * getUserParamValue(Channel1Pan_e, value));
}

void Mix4::channel2pan(float value)
{
    // perform any necessary conversion to user variables, validation, etc.
    m_channel2pan = std::sin(0.5f * PI_F * getUserParamValue(Channel2Pan_e, value));
}

void Mix4::channel3pan(float value)
{
    // perform any necessary conversion to user variables, validation, etc.
    m_channel3pan = std::sin(0.5f * PI_F * getUserParamValue(Channel3Pan_e, value));
}

void Mix4::channel4pan(float value)
{
    // perform any necessary conversion to user variables, validation, etc.
    m_channel4pan = std::sin(0.5f * PI_F * getUserParamValue(Channel4Pan_e, value));
}

void Mix4::master1(float value)
{
    // perform any necessary conversion to user variables, validation, etc.
    m_master1 = levelDb(getUserParamValue(Master1_e,value));
}

void Mix4::master2(float value)
{
    // perform any necessary conversion to user variables, validation, etc.
    m_master2 = levelDb(getUserParamValue(Master2_e,value));
}

}
